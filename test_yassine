#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <sys/stat.h>
#include "shell.h"

int is_builtin(char *command)
{
    return (strcmp(command, "cd") == 0 ||
            strcmp(command, "exit") == 0 ||
            strcmp(command, "env") == 0 ||
            strcmp(command, "setenv") == 0 ||
            strcmp(command, "unsetenv") == 0);
}

int handle_cd(char **args)
{
    if (!args[1])
    {
        char *home = getenv("HOME");
        if (home)
            return chdir(home);
        return 1;
    }
    if (chdir(args[1]) != 0)
    {
        perror("cd");
        return 1;
    }
    return 0;
}

int handle_exit(char **args)
{
    int status = 0;
    if (args[1])
        status = atoi(args[1]);
    return status;
}

char *find_executable(char *command)
{
    struct stat st;
    
    if (strchr(command, '/') != NULL)
    {
        if (stat(command, &st) == 0)
            return strdup(command);
        return NULL;
    }

    char *path = getenv("PATH");
    if (!path)
        return NULL;

    char *path_copy = strdup(path);
    if (!path_copy)
        return NULL;

    char *dir = strtok(path_copy, ":");
    char *full_path = NULL;

    while (dir != NULL)
    {
        full_path = malloc(strlen(dir) + strlen(command) + 2);
        if (!full_path)
        {
            perror("malloc");
            free(path_copy);
            return NULL;
        }
        sprintf(full_path, "%s/%s", dir, command);
        
        if (stat(full_path, &st) == 0)
        {
            free(path_copy);
            return full_path;
        }
        free(full_path);
        dir = strtok(NULL, ":");
    }
    free(path_copy);
    return NULL;
}

void tokenize_input(char *line, char **args)
{
    char *token;
    int i = 0;

    token = strtok(line, " \n\t");
    while (token != NULL && i < MAX_ARGS - 1)
    {
        args[i++] = token;
        token = strtok(NULL, " \n\t");
    }
    args[i] = NULL;
}

void execute_command(char **args, int linecount, char **argv)
{
    char *path_command;
    
    if (!args[0])
        return;

    if (is_builtin(args[0]))
    {
        if (strcmp(args[0], "cd") == 0)
            handle_cd(args);
        else if (strcmp(args[0], "env") == 0)
            print_env();
        return;
    }

    path_command = find_executable(args[0]);
    if (path_command)
    {
        if (execve(path_command, args, environ) == -1)
        {
            fprintf(stderr, "%s: %d: %s: not found\n", argv[0], linecount, args[0]);
            free(path_command);
            exit(127);
        }
    }
    else
    {
        fprintf(stderr, "%s: %d: %s: not found\n", argv[0], linecount, args[0]);
        exit(127);
    }
}

void shell_loop(char **argv)
{
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    int status = 0;
    int linecount = 1;
    char *args[MAX_ARGS];

    while (1)
    {
        printf("callayass_shell$ ");
        read = getline(&line, &len, stdin);
        
        if (read == -1)
        {
            printf("\n");
            break;
        }

        line[strcspn(line, "\n")] = '\0';
        if (strlen(line) == 0)
        {
            linecount++;
            continue;
        }

        tokenize_input(line, args);
        if (!args[0])
            continue;

        if (strcmp(args[0], "exit") == 0)
        {
            status = handle_exit(args);
            break;
        }

        pid_t pid = fork();
        if (pid == -1)
        {
            perror("fork");
            continue;
        }
        if (pid == 0)
        {
            execute_command(args, linecount, argv);
            exit(EXIT_FAILURE);
        }
        else
        {
            wait(&status);
        }
        linecount++;
    }
    free(line);
    exit(status);
}

int main(int ac, char **av)
{
    (void)ac;
    signal(SIGINT, SIG_IGN);
    shell_loop(av);
    return (0);
}
